#!/usr/bin/env bun
// threads CLI - Thread management for LLM workflows

import * as fs from 'fs';
import * as path from 'path';
import * as yaml from 'js-yaml';
import { Thread, extractIDFromPath, extractNameFromPath, baseStatus, isTerminal, isValidStatus, ALL_STATUSES } from '../src/thread';
import { findWorkspace, findAllThreads, inferScope, parseThreadPath, computeRelativePath, generateID, slugify, findByRef, findThreadsWithOptions, findGitRoot, FindOptions } from '../src/workspace';
import { insertLogEntry, addNote, removeByHash, editByHash, addTodoItem, setTodoChecked, countMatchingItems, replaceSection, appendToSection } from '../src/section';
import { formatDate, formatTime, getErrorMessage } from '../src/utils';
import * as git from '../src/git';

// Output format types
type OutputFormat = 'fancy' | 'plain' | 'json' | 'yaml';

// Parse format flag, with --json taking precedence
function resolveFormat(flags: Record<string, string | boolean>): OutputFormat {
  if (flags.json === true) {
    return 'json';
  }
  const fmt = flags.format as string | undefined;
  if (fmt) {
    const lower = fmt.toLowerCase();
    if (lower === 'json' || lower === 'yaml' || lower === 'plain') {
      return lower as OutputFormat;
    }
    if (lower === 'fancy') {
      return 'fancy';
    }
    console.error(`Error: invalid format '${fmt}'. Use: json, yaml, plain`);
    process.exit(1);
  }
  return 'fancy';
}

// Parse command line arguments
const args = Bun.argv.slice(2);

// Global workspace variable
let ws: string;

// Helper to get workspace (with error handling)
function getWorkspace(): string {
  if (!ws) {
    try {
      ws = findWorkspace();
    } catch (e: unknown) {
      console.error(`Error: ${getErrorMessage(e)}`);
      process.exit(1);
    }
  }
  return ws;
}

// Flags that take values (need to consume next arg when space-separated)
const VALUE_FLAGS = new Set([
  'down', 'd', 'up', 'u', 'format', 'f', 'search', 's',
  'category', 'c', 'project', 'p', 'status', 'm', 'set'
]);

// Parse flags from args
function parseFlags(args: string[]): { flags: Record<string, string | boolean>; positional: string[] } {
  const flags: Record<string, string | boolean> = {};
  const positional: string[] = [];

  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg.startsWith('--')) {
      const eqIdx = arg.indexOf('=');
      if (eqIdx !== -1) {
        // --flag=value
        flags[arg.substring(2, eqIdx)] = arg.substring(eqIdx + 1);
      } else {
        // --flag or --flag value
        const key = arg.substring(2);
        if (VALUE_FLAGS.has(key) && i + 1 < args.length && !args[i + 1].startsWith('-')) {
          flags[key] = args[++i];
        } else {
          flags[key] = true;
        }
      }
    } else if (arg.startsWith('-') && arg.length === 2) {
      // Short flag like -r, -m
      const key = arg.substring(1);
      // Check if next arg is the value (for flags that take values)
      if (VALUE_FLAGS.has(key) && i + 1 < args.length && !args[i + 1].startsWith('-')) {
        flags[key] = args[++i];
      } else {
        flags[key] = true;
      }
    } else if (arg.startsWith('-') && arg.length > 2 && arg[2] === '=') {
      // -f=value format
      flags[arg.substring(1, 2)] = arg.substring(3);
    } else {
      positional.push(arg);
    }
  }

  return { flags, positional };
}

// Check if stdin has data available
function stdinHasData(): boolean {
  return !process.stdin.isTTY;
}

// Read all stdin
async function readStdin(): Promise<string> {
  if (!stdinHasData()) {
    return '';
  }
  const chunks: Buffer[] = [];
  for await (const chunk of Bun.stdin.stream()) {
    chunks.push(Buffer.from(chunk));
  }
  return Buffer.concat(chunks).toString('utf-8');
}

// Truncate string for display
function truncate(s: string, max: number): string {
  if (s.length <= max) {
    return s;
  }
  return s.substring(0, max - 1) + '…';
}

// ============== Commands ==============

// list command
async function cmdList(args: string[]): Promise<void> {
  const { flags, positional } = parseFlags(args);

  // Validate flags
  const validFlags = ['search', 's', 'status', 'r', 'recursive', 'include-closed', 'json', 'down', 'd', 'up', 'u'];
  for (const flag in flags) {
    if (!validFlags.includes(flag)) {
      console.error(`Unknown option: ${flag}`);
      process.exit(1);
    }
  }

  const ws = getWorkspace();
  let gitRoot: string;
  try {
    gitRoot = findGitRoot();
  } catch {
    gitRoot = ws;
  }

  let pathFilter = positional[0] || '';
  let listCategory = '';
  let listProject = '';
  let listSearch = (flags.search || flags.s || '') as string;
  const listStatus = flags.status as string | undefined;
  const listRecursive = !!flags.r || !!flags.recursive;
  const listIncludeClosed = !!flags['include-closed'];
  const listJSON = !!flags.json;

  // Parse --down/-d and --up/-u flags
  // Semantics: 0 = unlimited, N > 0 = N levels, undefined = not set (no recursion)
  let downDepth: number | undefined;
  let upDepth: number | undefined;

  // Handle --down or -d
  const downFlag = flags.down ?? flags.d;
  if (downFlag !== undefined) {
    if (typeof downFlag === 'string') {
      downDepth = parseInt(downFlag, 10);
      if (isNaN(downDepth)) {
        console.error(`Error: invalid --down value: ${downFlag}`);
        process.exit(1);
      }
    } else if (downFlag === true) {
      // --down without value = unlimited (0)
      downDepth = 0;
    }
  }

  // Handle --up or -u
  const upFlag = flags.up ?? flags.u;
  if (upFlag !== undefined) {
    if (typeof upFlag === 'string') {
      upDepth = parseInt(upFlag, 10);
      if (isNaN(upDepth)) {
        console.error(`Error: invalid --up value: ${upFlag}`);
        process.exit(1);
      }
    } else if (upFlag === true) {
      // --up without value = unlimited (0)
      upDepth = 0;
    }
  }

  // -r/--recursive is an alias for --down=0 (unlimited depth)
  if (listRecursive && downDepth === undefined) {
    downDepth = 0;
  }

  // Determine start path for direction-based search
  let startPath = process.cwd();
  if (pathFilter) {
    const fullPath = path.join(ws, pathFilter);
    if (fs.existsSync(fullPath) && fs.statSync(fullPath).isDirectory()) {
      startPath = fullPath;
      const parts = pathFilter.split('/').slice(0, 2);
      listCategory = parts[0];
      if (parts.length > 1) {
        listProject = parts[1];
      }
    } else {
      // Treat as search filter
      listSearch = pathFilter;
    }
  }

  // Determine if we're using direction-based search
  const hasDirectionFlags = downDepth !== undefined || upDepth !== undefined;

  // Find threads
  let threads: string[];
  if (hasDirectionFlags) {
    const options: FindOptions = {};
    if (downDepth !== undefined) {
      options.down = downDepth;
    }
    if (upDepth !== undefined) {
      options.up = upDepth;
    }
    threads = findThreadsWithOptions(startPath, gitRoot, options);
  } else {
    threads = findAllThreads(ws);
  }

  interface ThreadInfo {
    id: string;
    status: string;
    category: string;
    project: string;
    name: string;
    title: string;
    desc: string;
  }

  const results: ThreadInfo[] = [];

  for (const threadPath of threads) {
    let t: Thread;
    try {
      t = Thread.parse(threadPath);
    } catch {
      continue;
    }

    const { category, project, name } = parseThreadPath(ws, threadPath);
    const status = t.status;
    const base = baseStatus(status);

    // When NOT using direction flags, apply path-based filtering
    if (!hasDirectionFlags) {
      // Category filter
      if (listCategory && category !== listCategory) {
        continue;
      }

      // Project filter
      if (listProject && project !== listProject) {
        continue;
      }

      // Non-recursive: only threads at current hierarchy level
      if (listProject) {
        // At project level, show all threads here
      } else if (listCategory) {
        // At category level: only show category-level threads
        if (project !== '-') {
          continue;
        }
      } else {
        // At workspace level: only show workspace-level threads
        if (category !== '-') {
          continue;
        }
      }
    }

    // Status filter
    if (listStatus !== undefined) {
      // Status filter was explicitly provided
      if (listStatus === '') {
        // Empty status value matches nothing
        continue;
      }
      if (!listStatus.split(',').includes(base)) {
        continue;
      }
    } else {
      // No status filter: apply default terminal filtering
      if (!listIncludeClosed && isTerminal(status)) {
        continue;
      }
    }

    // Search filter
    if (listSearch) {
      const searchLower = listSearch.toLowerCase();
      const nameLower = name.toLowerCase();
      const titleLower = t.name.toLowerCase();
      const descLower = t.frontmatter.desc.toLowerCase();

      if (!nameLower.includes(searchLower) &&
          !titleLower.includes(searchLower) &&
          !descLower.includes(searchLower)) {
        continue;
      }
    }

    // Use title if available, else humanize name
    let title = t.name;
    if (!title) {
      title = name.replace(/-/g, ' ');
    }

    // Compute git-relative path
    const relPath = computeRelativePath(ws, threadPath);

    results.push({
      id: t.id,
      status: base,
      path: relPath,
      name,
      title,
      desc: t.frontmatter.desc,
    });
  }

  if (listJSON) {
    console.log(JSON.stringify(results, null, 2));
    return;
  }

  // Build header description
  let levelDesc: string;
  let pathSuffix = '';

  if (listProject && listCategory) {
    levelDesc = 'project-level';
    pathSuffix = ` (${listCategory}/${listProject})`;
  } else if (listCategory) {
    levelDesc = 'category-level';
    pathSuffix = ` (${listCategory})`;
  } else {
    levelDesc = 'workspace-level';
  }

  let statusDesc = 'active';
  if (listStatus) {
    statusDesc = listStatus;
  } else if (listIncludeClosed) {
    statusDesc = '';
  }

  // Build direction suffix
  let directionSuffix = '';
  if (hasDirectionFlags) {
    const parts: string[] = [];
    if (downDepth !== undefined) {
      if (downDepth === 0) {
        parts.push('recursive');
      } else {
        parts.push(`down ${downDepth}`);
      }
    }
    if (upDepth !== undefined) {
      if (upDepth === 0) {
        parts.push('up');
      } else {
        parts.push(`up ${upDepth}`);
      }
    }
    if (parts.length > 0) {
      directionSuffix = ` (${parts.join(', ')})`;
    }
  }

  if (statusDesc) {
    console.log(`Showing ${results.length} ${statusDesc} ${levelDesc} threads${pathSuffix}${directionSuffix}`);
  } else {
    console.log(`Showing ${results.length} ${levelDesc} threads${pathSuffix} (all statuses)${directionSuffix}`);
  }
  console.log();

  if (results.length === 0) {
    if (!hasDirectionFlags) {
      console.log('Hint: use -r to include nested categories/projects');
    }
    return;
  }

  // Print table header
  console.log(`${'ID'.padEnd(6)} ${'STATUS'.padEnd(10)} ${'PATH'.padEnd(24)} NAME`);
  console.log(`${'--'.padEnd(6)} ${'------'.padEnd(10)} ${'----'.padEnd(24)} ----`);

  for (const t of results) {
    const pathDisplay = truncate(t.path, 22);
    // Use String() to guard against non-string values from malformed thread files
    console.log(`${String(t.id || '').padEnd(6)} ${String(t.status || '').padEnd(10)} ${pathDisplay.padEnd(24)} ${t.title || ''}`);
  }
}

// new command
async function cmdNew(args: string[]): Promise<void> {
  const { flags, positional } = parseFlags(args);
  const ws = getWorkspace();
  const fmt = resolveFormat(flags);

  let targetPath: string;
  let title: string;

  if (positional.length === 2) {
    targetPath = positional[0];
    title = positional[1];
  } else if (positional.length === 1) {
    title = positional[0];
    targetPath = process.cwd();
  } else {
    console.error('Usage: threads new [path] <title>');
    process.exit(1);
  }

  if (!title) {
    console.error('Error: title is required');
    process.exit(1);
  }

  const newStatus = (flags.status || 'idea') as string;
  const newDesc = (flags.desc || '') as string;
  let newBody = (flags.body || '') as string;

  // Validate status if provided via --status
  if (flags.status && !isValidStatus(newStatus)) {
    console.error(`Error: Invalid status '${newStatus}'. Must be one of: ${ALL_STATUSES.join(', ')}`);
    process.exit(1);
  }

  // Warn if no description provided (only in plain/fancy mode)
  if (!newDesc && (fmt === 'fancy' || fmt === 'plain')) {
    console.error('Warning: No --desc provided. Add one with: threads update <id> --desc "..."');
  }

  // Slugify title
  const slug = slugify(title);
  if (!slug) {
    console.error('Error: title produces empty slug');
    process.exit(1);
  }

  // Read body from stdin if available and not provided via flag
  if (!newBody && stdinHasData()) {
    newBody = await readStdin();
  }

  // Determine scope
  let scope;
  try {
    scope = inferScope(ws, targetPath);
  } catch (e: unknown) {
    console.error(`Error: ${getErrorMessage(e)}`);
    process.exit(1);
  }

  // Generate ID
  const id = generateID(ws);

  // Ensure threads directory exists
  fs.mkdirSync(scope.threadsDir, { recursive: true });

  // Build file path
  const filename = `${id}-${slug}.md`;
  const threadPath = path.join(scope.threadsDir, filename);

  // Check if file already exists
  if (fs.existsSync(threadPath)) {
    console.error(`Error: thread already exists: ${threadPath}`);
    process.exit(1);
  }

  // Generate content
  const today = formatDate(new Date());
  const timestamp = formatTime(new Date());

  let content = '---\n';
  content += `id: ${id}\n`;
  content += `name: ${title}\n`;
  content += `desc: ${newDesc}\n`;
  content += `status: ${newStatus}\n`;
  content += '---\n\n';

  if (newBody) {
    content += newBody;
    if (!newBody.endsWith('\n')) {
      content += '\n';
    }
    content += '\n';
  }

  content += '## Todo\n\n';
  content += '## Log\n\n';
  content += `### ${today}\n\n`;
  content += `- **${timestamp}** Created thread.\n`;

  // Write file
  fs.writeFileSync(threadPath, content);

  const relPath = path.relative(ws, threadPath);
  const absPath = path.resolve(threadPath);

  // Output based on format
  switch (fmt) {
    case 'json':
      console.log(JSON.stringify({ id, path: relPath, path_absolute: absPath }, null, 2));
      break;
    case 'yaml':
      console.log(yaml.dump({ id, path: relPath, path_absolute: absPath }));
      break;
    case 'fancy':
    case 'plain':
    default:
      console.log(`Created ${scope.levelDesc}: ${id}`);
      console.log(`  → ${relPath}`);
      if (!newBody) {
        console.error(`Hint: Add body with: echo "content" | threads body ${id} --set`);
      }
      break;
  }

  // Commit if requested
  if (flags.commit) {
    const msg = (flags.m || git.generateCommitMessage(ws, [threadPath])) as string;
    try {
      git.autoCommit(ws, threadPath, msg);
    } catch (e: unknown) {
      console.error(`Error: ${getErrorMessage(e)}`);
      process.exit(1);
    }
  } else if (fmt === 'fancy' || fmt === 'plain') {
    console.log(`Note: Thread ${id} has uncommitted changes. Use 'threads commit ${id}' when ready.`);
  }
}

// read command
async function cmdRead(args: string[]): Promise<void> {
  const { positional } = parseFlags(args);
  const ws = getWorkspace();

  if (positional.length < 1) {
    console.error('Usage: threads read <id>');
    process.exit(1);
  }

  const ref = positional[0];

  let file: string;
  try {
    file = findByRef(ws, ref);
  } catch (e: unknown) {
    console.error(`Error: ${getErrorMessage(e)}`);
    process.exit(1);
  }

  const content = fs.readFileSync(file, 'utf-8');
  process.stdout.write(content);
}

// path command
async function cmdPath(args: string[]): Promise<void> {
  const { flags, positional } = parseFlags(args);
  const ws = getWorkspace();
  const fmt = resolveFormat(flags);

  if (positional.length < 1) {
    console.error('Usage: threads path <id>');
    process.exit(1);
  }

  const ref = positional[0];

  let file: string;
  try {
    file = findByRef(ws, ref);
  } catch (e: unknown) {
    console.error(`Error: ${getErrorMessage(e)}`);
    process.exit(1);
  }

  const absPath = path.resolve(file);
  const relPath = path.relative(ws, file);

  // Output based on format
  switch (fmt) {
    case 'json':
      console.log(JSON.stringify({ path: relPath, path_absolute: absPath }, null, 2));
      break;
    case 'yaml':
      console.log(yaml.dump({ path: relPath, path_absolute: absPath }));
      break;
    case 'fancy':
    case 'plain':
    default:
      console.log(absPath);
      break;
  }
}

// status command
async function cmdStatus(args: string[]): Promise<void> {
  const { flags, positional } = parseFlags(args);
  const ws = getWorkspace();

  if (positional.length < 2) {
    console.error('Usage: threads status <id> <new-status>');
    process.exit(1);
  }

  const ref = positional[0];
  const newStatus = positional[1];

  // Validate status before applying
  if (!isValidStatus(newStatus)) {
    console.error(`Error: Invalid status '${newStatus}'. Must be one of: ${ALL_STATUSES.join(', ')}`);
    process.exit(1);
  }

  let file: string;
  try {
    file = findByRef(ws, ref);
  } catch (e: unknown) {
    console.error(`Error: ${getErrorMessage(e)}`);
    process.exit(1);
  }

  const t = Thread.parse(file);
  const oldStatus = t.status;

  t.setFrontmatterField('status', newStatus);
  t.write();

  console.log(`Status changed: ${oldStatus} → ${newStatus} (${file})`);

  if (flags.commit) {
    const msg = (flags.m || git.generateCommitMessage(ws, [file])) as string;
    try {
      git.autoCommit(ws, file, msg);
    } catch (e: unknown) {
      console.error(`Error: ${getErrorMessage(e)}`);
      process.exit(1);
    }
  } else {
    console.log(`Note: Thread ${ref} has uncommitted changes. Use 'threads commit ${ref}' when ready.`);
  }
}

// update command
async function cmdUpdate(args: string[]): Promise<void> {
  const { flags, positional } = parseFlags(args);
  const ws = getWorkspace();

  if (positional.length < 1) {
    console.error('Usage: threads update <id> [--title=X] [--desc=X]');
    process.exit(1);
  }

  const ref = positional[0];
  const updateTitle = flags.title as string | undefined;
  const updateDesc = flags.desc as string | undefined;

  if (!updateTitle && updateDesc === undefined) {
    console.error('Error: specify --title and/or --desc');
    process.exit(1);
  }

  let file: string;
  try {
    file = findByRef(ws, ref);
  } catch (e: unknown) {
    console.error(`Error: ${getErrorMessage(e)}`);
    process.exit(1);
  }

  const t = Thread.parse(file);

  if (updateTitle) {
    t.setFrontmatterField('name', updateTitle);
    console.log(`Title updated: ${updateTitle}`);
  }

  if (updateDesc !== undefined) {
    t.setFrontmatterField('desc', updateDesc);
    console.log(`Description updated: ${updateDesc}`);
  }

  t.write();
  console.log(`Updated: ${file}`);

  if (flags.commit) {
    const msg = (flags.m || git.generateCommitMessage(ws, [file])) as string;
    try {
      git.autoCommit(ws, file, msg);
    } catch (e: unknown) {
      console.error(`Error: ${getErrorMessage(e)}`);
      process.exit(1);
    }
  } else {
    console.log(`Note: Thread ${ref} has uncommitted changes. Use 'threads commit ${ref}' when ready.`);
  }
}

// body command
async function cmdBody(args: string[]): Promise<void> {
  const { flags, positional } = parseFlags(args);
  const ws = getWorkspace();

  if (positional.length < 1) {
    console.error('Usage: threads body <id> [--set|--append]');
    process.exit(1);
  }

  const ref = positional[0];
  const bodySet = !!flags.set;
  const bodyAppend = !!flags.append;

  // Default to set mode
  const useSet = bodySet || !bodyAppend;

  // Read content from stdin
  let content = '';
  if (stdinHasData()) {
    content = await readStdin();
  }

  if (!content) {
    console.error('Error: no content provided (use stdin)');
    process.exit(1);
  }

  let file: string;
  try {
    file = findByRef(ws, ref);
  } catch (e: unknown) {
    console.error(`Error: ${getErrorMessage(e)}`);
    process.exit(1);
  }

  const t = Thread.parse(file);

  if (useSet) {
    t.content = replaceSection(t.content, 'Body', content);
  } else {
    t.content = appendToSection(t.content, 'Body', content);
  }

  t.write();

  const mode = useSet ? 'set' : 'append';
  console.log(`Body ${mode}: ${file}`);

  if (flags.commit) {
    const msg = (flags.m || git.generateCommitMessage(ws, [file])) as string;
    try {
      git.autoCommit(ws, file, msg);
    } catch (e: unknown) {
      console.error(`Error: ${getErrorMessage(e)}`);
      process.exit(1);
    }
  } else {
    console.log(`Note: Thread ${ref} has uncommitted changes. Use 'threads commit ${ref}' when ready.`);
  }
}

// note command
async function cmdNote(args: string[]): Promise<void> {
  const { flags, positional } = parseFlags(args);
  const ws = getWorkspace();

  if (positional.length < 2) {
    console.error('Usage: threads note <id> <action> [text|hash] [new-text]');
    process.exit(1);
  }

  const ref = positional[0];
  const action = positional[1];

  let file: string;
  try {
    file = findByRef(ws, ref);
  } catch (e: unknown) {
    console.error(`Error: ${getErrorMessage(e)}`);
    process.exit(1);
  }

  const t = Thread.parse(file);

  switch (action) {
    case 'add': {
      if (positional.length < 3) {
        console.error('Usage: threads note <id> add "text"');
        process.exit(1);
      }
      const text = positional[2];

      const result = addNote(t.content, text);
      t.content = result.content;

      // Add log entry
      t.content = insertLogEntry(t.content, `Added note: ${text}`);

      console.log(`Added note: ${text} (id: ${result.hash})`);
      break;
    }
    case 'edit': {
      if (positional.length < 4) {
        console.error('Usage: threads note <id> edit <hash> "new text"');
        process.exit(1);
      }
      const hash = positional[2];
      const newText = positional[3];

      // Check for ambiguous hash
      const count = countMatchingItems(t.content, 'Notes', hash);
      if (count === 0) {
        console.error(`Error: no note with hash '${hash}' found`);
        process.exit(1);
      }
      if (count > 1) {
        console.error(`Error: ambiguous hash '${hash}' matches ${count} notes`);
        process.exit(2);
      }

      t.content = editByHash(t.content, 'Notes', hash, newText);
      t.content = insertLogEntry(t.content, `Edited note ${hash}`);

      console.log(`Edited note ${hash}`);
      break;
    }
    case 'remove': {
      if (positional.length < 3) {
        console.error('Usage: threads note <id> remove <hash>');
        process.exit(1);
      }
      const hash = positional[2];

      // Check for ambiguous hash
      const count = countMatchingItems(t.content, 'Notes', hash);
      if (count === 0) {
        console.error(`Error: no note with hash '${hash}' found`);
        process.exit(1);
      }
      if (count > 1) {
        console.error(`Error: ambiguous hash '${hash}' matches ${count} notes`);
        process.exit(2);
      }

      t.content = removeByHash(t.content, 'Notes', hash);
      t.content = insertLogEntry(t.content, `Removed note ${hash}`);

      console.log(`Removed note ${hash}`);
      break;
    }
    default:
      console.error(`Error: unknown action '${action}'. Use: add, edit, remove`);
      process.exit(1);
  }

  t.write();

  if (flags.commit) {
    const msg = (flags.m || git.generateCommitMessage(ws, [file])) as string;
    try {
      git.autoCommit(ws, file, msg);
    } catch (e: unknown) {
      console.error(`Error: ${getErrorMessage(e)}`);
      process.exit(1);
    }
  } else {
    console.log(`Note: Thread ${ref} has uncommitted changes. Use 'threads commit ${ref}' when ready.`);
  }
}

// todo command
async function cmdTodo(args: string[]): Promise<void> {
  const { flags, positional } = parseFlags(args);
  const ws = getWorkspace();

  if (positional.length < 2) {
    console.error('Usage: threads todo <id> <action> [item|hash]');
    process.exit(1);
  }

  const ref = positional[0];
  const action = positional[1];

  let file: string;
  try {
    file = findByRef(ws, ref);
  } catch (e: unknown) {
    console.error(`Error: ${getErrorMessage(e)}`);
    process.exit(1);
  }

  const t = Thread.parse(file);

  switch (action) {
    case 'add': {
      if (positional.length < 3) {
        console.error('Usage: threads todo <id> add "item text"');
        process.exit(1);
      }
      const text = positional[2];

      const result = addTodoItem(t.content, text);
      t.content = result.content;

      console.log(`Added to Todo: ${text} (id: ${result.hash})`);
      break;
    }
    case 'check':
    case 'complete':
    case 'done': {
      if (positional.length < 3) {
        console.error('Usage: threads todo <id> check <hash>');
        process.exit(1);
      }
      const hash = positional[2];

      const count = countMatchingItems(t.content, 'Todo', hash);
      if (count === 0) {
        console.error(`Error: no unchecked item with hash '${hash}' found`);
        process.exit(1);
      }
      if (count > 1) {
        console.error(`Error: ambiguous hash '${hash}' matches ${count} items`);
        process.exit(2);
      }

      t.content = setTodoChecked(t.content, hash, true);
      console.log(`Checked item ${hash}`);
      break;
    }
    case 'uncheck': {
      if (positional.length < 3) {
        console.error('Usage: threads todo <id> uncheck <hash>');
        process.exit(1);
      }
      const hash = positional[2];

      const count = countMatchingItems(t.content, 'Todo', hash);
      if (count === 0) {
        console.error(`Error: no checked item with hash '${hash}' found`);
        process.exit(1);
      }
      if (count > 1) {
        console.error(`Error: ambiguous hash '${hash}' matches ${count} items`);
        process.exit(2);
      }

      t.content = setTodoChecked(t.content, hash, false);
      console.log(`Unchecked item ${hash}`);
      break;
    }
    case 'remove': {
      if (positional.length < 3) {
        console.error('Usage: threads todo <id> remove <hash>');
        process.exit(1);
      }
      const hash = positional[2];

      const count = countMatchingItems(t.content, 'Todo', hash);
      if (count === 0) {
        console.error(`Error: no item with hash '${hash}' found`);
        process.exit(1);
      }
      if (count > 1) {
        console.error(`Error: ambiguous hash '${hash}' matches ${count} items`);
        process.exit(2);
      }

      t.content = removeByHash(t.content, 'Todo', hash);
      console.log(`Removed item ${hash}`);
      break;
    }
    case 'toggle': {
      // Support toggle as well
      if (positional.length < 3) {
        console.error('Usage: threads todo <id> toggle <hash>');
        process.exit(1);
      }
      const hash = positional[2];

      const count = countMatchingItems(t.content, 'Todo', hash);
      if (count === 0) {
        console.error(`Error: no item with hash '${hash}' found`);
        process.exit(1);
      }
      if (count > 1) {
        console.error(`Error: ambiguous hash '${hash}' matches ${count} items`);
        process.exit(2);
      }

      // Check if currently checked or not by looking at the content
      const lines = t.content.split('\n');
      let isChecked = false;
      for (const line of lines) {
        if (line.includes(`<!-- ${hash}`) && line.includes('[x]')) {
          isChecked = true;
          break;
        }
      }

      t.content = setTodoChecked(t.content, hash, !isChecked);
      console.log(isChecked ? `Unchecked item ${hash}` : `Checked item ${hash}`);
      break;
    }
    default:
      console.error(`Error: unknown action '${action}'. Use: add, check, uncheck, remove`);
      process.exit(1);
  }

  t.write();

  if (flags.commit) {
    const msg = (flags.m || git.generateCommitMessage(ws, [file])) as string;
    try {
      git.autoCommit(ws, file, msg);
    } catch (e: unknown) {
      console.error(`Error: ${getErrorMessage(e)}`);
      process.exit(1);
    }
  } else {
    console.log(`Note: Thread ${ref} has uncommitted changes. Use 'threads commit ${ref}' when ready.`);
  }
}

// log command
async function cmdLog(args: string[]): Promise<void> {
  const { flags, positional } = parseFlags(args);
  const ws = getWorkspace();

  if (positional.length < 1) {
    console.error('Usage: threads log <id> [entry]');
    process.exit(1);
  }

  const ref = positional[0];
  let entry = positional[1] || '';

  // Read entry from stdin if not provided
  if (!entry && stdinHasData()) {
    entry = (await readStdin()).trim();
  }

  if (!entry) {
    console.error('Error: no log entry provided');
    process.exit(1);
  }

  let file: string;
  try {
    file = findByRef(ws, ref);
  } catch (e: unknown) {
    console.error(`Error: ${getErrorMessage(e)}`);
    process.exit(1);
  }

  const t = Thread.parse(file);
  t.content = insertLogEntry(t.content, entry);
  t.write();

  console.log(`Logged to: ${file}`);

  if (flags.commit) {
    const msg = (flags.m || git.generateCommitMessage(ws, [file])) as string;
    try {
      git.autoCommit(ws, file, msg);
    } catch (e: unknown) {
      console.error(`Error: ${getErrorMessage(e)}`);
      process.exit(1);
    }
  } else {
    console.log(`Note: Thread ${ref} has uncommitted changes. Use 'threads commit ${ref}' when ready.`);
  }
}

// resolve command
async function cmdResolve(args: string[]): Promise<void> {
  const { flags, positional } = parseFlags(args);
  const ws = getWorkspace();

  if (positional.length < 1) {
    console.error('Usage: threads resolve <id>');
    process.exit(1);
  }

  const ref = positional[0];

  let file: string;
  try {
    file = findByRef(ws, ref);
  } catch (e: unknown) {
    console.error(`Error: ${getErrorMessage(e)}`);
    process.exit(1);
  }

  const t = Thread.parse(file);
  const oldStatus = t.status;

  t.setFrontmatterField('status', 'resolved');
  t.content = insertLogEntry(t.content, 'Resolved.');
  t.write();

  console.log(`Resolved: ${oldStatus} → resolved (${file})`);

  if (flags.commit) {
    const msg = (flags.m || git.generateCommitMessage(ws, [file])) as string;
    try {
      git.autoCommit(ws, file, msg);
    } catch (e: unknown) {
      console.error(`Error: ${getErrorMessage(e)}`);
      process.exit(1);
    }
  } else {
    console.log(`Note: Thread ${ref} has uncommitted changes. Use 'threads commit ${ref}' when ready.`);
  }
}

// reopen command
async function cmdReopen(args: string[]): Promise<void> {
  const { flags, positional } = parseFlags(args);
  const ws = getWorkspace();

  if (positional.length < 1) {
    console.error('Usage: threads reopen <id> [--status=X]');
    process.exit(1);
  }

  const ref = positional[0];
  const reopenStatus = (flags.status || 'active') as string;

  // Validate status if provided via --status
  if (flags.status && !isValidStatus(reopenStatus)) {
    console.error(`Error: Invalid status '${reopenStatus}'. Must be one of: ${ALL_STATUSES.join(', ')}`);
    process.exit(1);
  }

  let file: string;
  try {
    file = findByRef(ws, ref);
  } catch (e: unknown) {
    console.error(`Error: ${getErrorMessage(e)}`);
    process.exit(1);
  }

  const t = Thread.parse(file);
  const oldStatus = t.status;

  t.setFrontmatterField('status', reopenStatus);
  t.content = insertLogEntry(t.content, 'Reopened.');
  t.write();

  console.log(`Reopened: ${oldStatus} → ${reopenStatus} (${file})`);

  if (flags.commit) {
    const msg = (flags.m || git.generateCommitMessage(ws, [file])) as string;
    try {
      git.autoCommit(ws, file, msg);
    } catch (e: unknown) {
      console.error(`Error: ${getErrorMessage(e)}`);
      process.exit(1);
    }
  } else {
    console.log(`Note: Thread ${ref} has uncommitted changes. Use 'threads commit ${ref}' when ready.`);
  }
}

// remove command
async function cmdRemove(args: string[]): Promise<void> {
  const { flags, positional } = parseFlags(args);
  const ws = getWorkspace();

  if (positional.length < 1) {
    console.error('Usage: threads remove <id>');
    process.exit(1);
  }

  const ref = positional[0];

  let file: string;
  try {
    file = findByRef(ws, ref);
  } catch (e: unknown) {
    console.error(`Error: ${getErrorMessage(e)}`);
    process.exit(1);
  }

  const t = Thread.parse(file);
  const name = t.name;
  const relPath = path.relative(ws, file);

  // Check if file is tracked
  const wasTracked = git.isTracked(ws, relPath);

  // Remove file
  fs.unlinkSync(file);
  console.log(`Removed: ${file}`);

  if (!wasTracked) {
    console.log('Note: Thread was never committed to git, no commit needed.');
    return;
  }

  if (flags.commit) {
    const msg = (flags.m || `threads: remove '${name}'`) as string;
    try {
      git.add(ws, relPath);
      git.commit(ws, [relPath], msg);
    } catch (e: unknown) {
      console.error(`WARNING: ${getErrorMessage(e)}`);
    }
  } else {
    console.log('Note: To commit this removal, run:');
    console.log(`  git -C "$WORKSPACE" add "${relPath}" && git -C "$WORKSPACE" commit -m "threads: remove '${name}'"`);
  }
}

// move command
async function cmdMove(args: string[]): Promise<void> {
  const { flags, positional } = parseFlags(args);
  const ws = getWorkspace();

  if (positional.length < 2) {
    console.error('Usage: threads move <id> <new-path>');
    process.exit(1);
  }

  const ref = positional[0];
  const newPath = positional[1];

  let srcFile: string;
  try {
    srcFile = findByRef(ws, ref);
  } catch (e: unknown) {
    console.error(`Error: ${getErrorMessage(e)}`);
    process.exit(1);
  }

  let scope;
  try {
    scope = inferScope(ws, newPath);
  } catch (e: unknown) {
    console.error(`Error: invalid path: ${newPath}`);
    process.exit(1);
  }

  // Ensure dest .threads/ exists
  fs.mkdirSync(scope.threadsDir, { recursive: true });

  // Move file
  const filename = path.basename(srcFile);
  const destFile = path.join(scope.threadsDir, filename);

  if (fs.existsSync(destFile)) {
    console.error(`Error: thread already exists at destination: ${destFile}`);
    process.exit(1);
  }

  fs.renameSync(srcFile, destFile);

  const relDest = path.relative(ws, destFile);
  console.log(`Moved to ${scope.levelDesc}`);
  console.log(`  → ${relDest}`);

  if (flags.commit) {
    const relSrc = path.relative(ws, srcFile);
    try {
      git.add(ws, relSrc, relDest);
      const msg = (flags.m || `threads: move ${path.basename(srcFile)} to ${scope.levelDesc}`) as string;
      git.commit(ws, [relSrc, relDest], msg);
    } catch (e: unknown) {
      console.error(`WARNING: ${getErrorMessage(e)}`);
    }
  } else {
    console.log('Note: Use --commit to commit this move');
  }
}

// commit command
async function cmdCommit(args: string[]): Promise<void> {
  const { flags, positional } = parseFlags(args);
  const ws = getWorkspace();

  const commitPending = !!flags.pending;
  const commitMsg = (flags.m || '') as string;
  const commitAuto = !!flags.auto;

  let files: string[] = [];

  if (commitPending) {
    // Collect all thread files with uncommitted changes
    const threads = findAllThreads(ws);
    for (const t of threads) {
      const relPath = path.relative(ws, t);
      if (git.hasChanges(ws, relPath)) {
        files.push(t);
      }
    }
    // Also include deleted thread files
    const deleted = git.findDeletedThreadFiles(ws);
    files.push(...deleted);
  } else {
    // Resolve provided IDs to files
    if (positional.length === 0) {
      console.error('Error: provide thread IDs or use --pending');
      process.exit(1);
    }

    for (const id of positional) {
      let file: string;
      try {
        file = findByRef(ws, id);
      } catch (e: unknown) {
        console.error(`Error: ${getErrorMessage(e)}`);
        process.exit(1);
      }
      const relPath = path.relative(ws, file);
      if (!git.hasChanges(ws, relPath)) {
        console.log(`No changes in thread: ${id}`);
        continue;
      }
      files.push(file);
    }
  }

  if (files.length === 0) {
    console.log('No threads to commit.');
    return;
  }

  // Generate commit message if not provided
  let msg = commitMsg;
  if (!msg) {
    msg = git.generateCommitMessage(ws, files);
    console.log(`Generated message: ${msg}`);

    if (!commitAuto && process.stdin.isTTY) {
      // Read confirmation from user
      process.stdout.write('Proceed? [Y/n] ');
      const response = await new Promise<string>((resolve) => {
        const readline = require('readline');
        const rl = readline.createInterface({
          input: process.stdin,
          output: process.stdout,
        });
        rl.question('', (answer: string) => {
          rl.close();
          resolve(answer);
        });
      });

      if (response.toLowerCase() === 'n' || response.toLowerCase() === 'no') {
        console.log('Aborted.');
        return;
      }
    }
  }

  // Stage and commit
  const relPaths = files.map(f => path.relative(ws, f));

  try {
    git.commit(ws, relPaths, msg);
  } catch (e: unknown) {
    console.error(`Error: ${getErrorMessage(e)}`);
    process.exit(1);
  }

  console.log(`Committed ${files.length} thread(s).`);
}

// validate command
async function cmdValidate(args: string[]): Promise<void> {
  const { flags, positional } = parseFlags(args);
  const ws = getWorkspace();
  const fmt = resolveFormat(flags);

  let files: string[];

  if (positional.length > 0) {
    const target = positional[0];
    let absPath = target;
    if (!path.isAbsolute(target)) {
      absPath = path.join(ws, target);
    }
    files = [absPath];
  } else {
    files = findAllThreads(ws);
  }

  interface ValidationResult {
    path: string;
    valid: boolean;
    issues: string[];
  }

  const results: ValidationResult[] = [];
  let errorCount = 0;

  for (const file of files) {
    const relPath = path.relative(ws, file);
    const issues: string[] = [];

    try {
      const t = Thread.parse(file);

      if (!t.name) {
        issues.push('missing name/title field');
      }
      if (!t.status) {
        issues.push('missing status field');
      } else if (!isValidStatus(t.status)) {
        issues.push(`invalid status '${baseStatus(t.status)}'`);
      }
    } catch (e: unknown) {
      issues.push(`parse error: ${getErrorMessage(e)}`);
    }

    const valid = issues.length === 0;
    if (!valid) {
      errorCount++;
    }

    results.push({ path: relPath, valid, issues });
  }

  // Output based on format
  switch (fmt) {
    case 'json':
      console.log(JSON.stringify({ total: results.length, errors: errorCount, results }, null, 2));
      break;
    case 'yaml':
      console.log(yaml.dump({ total: results.length, errors: errorCount, results }));
      break;
    case 'fancy':
    case 'plain':
    default:
      for (const r of results) {
        if (r.valid) {
          console.log(`OK: ${r.path}`);
        } else {
          console.log(`WARN: ${r.path}: ${r.issues.join(', ')}`);
        }
      }
      break;
  }

  if (errorCount > 0) {
    if (fmt === 'fancy' || fmt === 'plain') {
      console.error(`${errorCount} validation error(s)`);
    }
    process.exit(1);
  }
}

// git command
async function cmdGit(args: string[]): Promise<void> {
  const ws = getWorkspace();

  const threads = findAllThreads(ws);
  const modified: string[] = [];

  for (const t of threads) {
    const relPath = path.relative(ws, t);
    if (git.hasChanges(ws, relPath)) {
      modified.push(relPath);
    }
  }

  if (modified.length === 0) {
    console.log('No pending thread changes.');
    return;
  }

  console.log('Pending thread changes:');
  for (const f of modified) {
    console.log(`  ${f}`);
  }
  console.log();
  console.log('Suggested:');
  console.log(`  git add ${modified.join(' ')} && git commit -m "threads: update" && git push`);
}

// stats command
async function cmdStats(args: string[]): Promise<void> {
  const { flags, positional } = parseFlags(args);
  const ws = getWorkspace();
  let gitRoot: string;
  try {
    gitRoot = findGitRoot();
  } catch {
    gitRoot = ws;
  }

  const statsRecursive = !!flags.r || !!flags.recursive;

  // Parse --down/-d and --up/-u flags
  // Semantics: 0 = unlimited, N > 0 = N levels, undefined = not set (no recursion)
  let downDepth: number | undefined;
  let upDepth: number | undefined;

  // Handle --down or -d
  const downFlag = flags.down ?? flags.d;
  if (downFlag !== undefined) {
    if (typeof downFlag === 'string') {
      downDepth = parseInt(downFlag, 10);
      if (isNaN(downDepth)) {
        console.error(`Error: invalid --down value: ${downFlag}`);
        process.exit(1);
      }
    } else if (downFlag === true) {
      // --down without value = unlimited (0)
      downDepth = 0;
    }
  }

  // Handle --up or -u
  const upFlag = flags.up ?? flags.u;
  if (upFlag !== undefined) {
    if (typeof upFlag === 'string') {
      upDepth = parseInt(upFlag, 10);
      if (isNaN(upDepth)) {
        console.error(`Error: invalid --up value: ${upFlag}`);
        process.exit(1);
      }
    } else if (upFlag === true) {
      // --up without value = unlimited (0)
      upDepth = 0;
    }
  }

  // -r/--recursive is an alias for --down=0 (unlimited depth)
  if (statsRecursive && downDepth === undefined) {
    downDepth = 0;
  }

  // Parse path filter
  let categoryFilter = '';
  let projectFilter = '';
  let startPath = process.cwd();
  if (positional.length > 0) {
    const pathFilter = positional[0];
    const fullPath = path.join(ws, pathFilter);
    if (fs.existsSync(fullPath) && fs.statSync(fullPath).isDirectory()) {
      startPath = fullPath;
      const parts = pathFilter.split('/').slice(0, 2);
      categoryFilter = parts[0];
      if (parts.length > 1) {
        projectFilter = parts[1];
      }
    }
  }

  // Determine if we're using direction-based search
  const hasDirectionFlags = downDepth !== undefined || upDepth !== undefined;

  // Find threads
  let threads: string[];
  if (hasDirectionFlags) {
    const options: FindOptions = {};
    if (downDepth !== undefined) {
      options.down = downDepth;
    }
    if (upDepth !== undefined) {
      options.up = upDepth;
    }
    threads = findThreadsWithOptions(startPath, gitRoot, options);
  } else {
    threads = findAllThreads(ws);
  }

  const counts: Record<string, number> = {};
  let total = 0;

  for (const threadPath of threads) {
    const { category, project } = parseThreadPath(ws, threadPath);

    // When NOT using direction flags, apply path-based filtering
    if (!hasDirectionFlags) {
      // Category filter
      if (categoryFilter && category !== categoryFilter) {
        continue;
      }

      // Project filter
      if (projectFilter && project !== projectFilter) {
        continue;
      }

      // Non-recursive: only threads at current hierarchy level
      if (projectFilter) {
        // At project level, count all
      } else if (categoryFilter) {
        if (project !== '-') {
          continue;
        }
      } else {
        if (category !== '-') {
          continue;
        }
      }
    }

    let t: Thread;
    try {
      t = Thread.parse(threadPath);
    } catch {
      continue;
    }

    let status = t.baseStatus();
    if (!status) {
      status = '(none)';
    }
    counts[status] = (counts[status] || 0) + 1;
    total++;
  }

  // Build scope description
  let levelDesc: string;
  let pathSuffix = '';
  if (projectFilter && categoryFilter) {
    levelDesc = 'project-level';
    pathSuffix = ` (${categoryFilter}/${projectFilter})`;
  } else if (categoryFilter) {
    levelDesc = 'category-level';
    pathSuffix = ` (${categoryFilter})`;
  } else {
    levelDesc = 'workspace-level';
  }

  // Build direction suffix
  let directionSuffix = '';
  if (hasDirectionFlags) {
    const parts: string[] = [];
    if (downDepth !== undefined) {
      if (downDepth === 0) {
        parts.push('recursive');
      } else {
        parts.push(`down ${downDepth}`);
      }
    }
    if (upDepth !== undefined) {
      if (upDepth === 0) {
        parts.push('up');
      } else {
        parts.push(`up ${upDepth}`);
      }
    }
    if (parts.length > 0) {
      directionSuffix = ` (${parts.join(', ')})`;
    }
  }

  console.log(`Stats for ${levelDesc} threads${pathSuffix}${directionSuffix}`);
  console.log();

  if (total === 0) {
    console.log('No threads found.');
    if (!hasDirectionFlags) {
      console.log('Hint: use -r to include nested categories/projects');
    }
    return;
  }

  // Sort by count descending
  const sorted = Object.entries(counts).sort((a, b) => b[1] - a[1]);

  console.log('| Status     | Count |');
  console.log('|------------|-------|');
  for (const [status, count] of sorted) {
    console.log(`| ${status.padEnd(10)} | ${String(count).padStart(5)} |`);
  }
  console.log('|------------|-------|');
  console.log(`| ${'Total'.padEnd(10)} | ${String(total).padStart(5)} |`);
}

// Print help message
function printHelp(): void {
  console.log('threads - Thread management for LLM workflows');
  console.log('');
  console.log('Usage: threads <command> [options]');
  console.log('');
  console.log('Commands:');
  console.log('  list [path]           List threads');
  console.log('  new [path] <title>    Create a new thread');
  console.log('  read <id>             Read thread content');
  console.log('  path <id>             Print thread file path');
  console.log('  status <id> <status>  Change thread status');
  console.log('  update <id>           Update thread title/desc');
  console.log('  body <id>             Edit Body section');
  console.log('  note <id> <action>    Manage notes');
  console.log('  todo <id> <action>    Manage todo items');
  console.log('  log <id> [entry]      Add log entry');
  console.log('  resolve <id>          Mark thread resolved');
  console.log('  reopen <id>           Reopen resolved thread');
  console.log('  remove <id>           Remove thread');
  console.log('  move <id> <path>      Move thread');
  console.log('  commit [ids]          Commit thread changes');
  console.log('  validate [path]       Validate thread files');
  console.log('  git                   Show pending changes');
  console.log('  stats [path]          Show thread stats');
  console.log('');
  console.log('Options:');
  console.log('  --help, -h            Show this help message');
}

// Main command dispatcher
async function main(): Promise<void> {
  // Handle help flag anywhere
  if (args.includes('--help') || args.includes('-h') || args.length === 0) {
    printHelp();
    return;
  }

  const command = args[0];
  const cmdArgs = args.slice(1);

  switch (command) {
    case 'list':
    case 'ls':
      await cmdList(cmdArgs);
      break;
    case 'new':
      await cmdNew(cmdArgs);
      break;
    case 'read':
      await cmdRead(cmdArgs);
      break;
    case 'path':
      await cmdPath(cmdArgs);
      break;
    case 'status':
      await cmdStatus(cmdArgs);
      break;
    case 'update':
      await cmdUpdate(cmdArgs);
      break;
    case 'body':
      await cmdBody(cmdArgs);
      break;
    case 'note':
      await cmdNote(cmdArgs);
      break;
    case 'todo':
      await cmdTodo(cmdArgs);
      break;
    case 'log':
      await cmdLog(cmdArgs);
      break;
    case 'resolve':
      await cmdResolve(cmdArgs);
      break;
    case 'reopen':
      await cmdReopen(cmdArgs);
      break;
    case 'remove':
    case 'rm':
      await cmdRemove(cmdArgs);
      break;
    case 'move':
      await cmdMove(cmdArgs);
      break;
    case 'commit':
      await cmdCommit(cmdArgs);
      break;
    case 'validate':
      await cmdValidate(cmdArgs);
      break;
    case 'git':
      await cmdGit(cmdArgs);
      break;
    case 'stats':
      await cmdStats(cmdArgs);
      break;
    default:
      console.error(`Unknown command: ${command}`);
      process.exit(1);
  }
}

main().catch(e => {
  console.error(`Error: ${e.message}`);
  process.exit(1);
});
