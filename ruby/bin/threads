#!/usr/bin/env ruby
# frozen_string_literal: true

# threads - Persistent context management for LLM-assisted development

# Try multiple paths to find lib (placement independent)
[
  File.expand_path('../lib', __dir__),      # Standard: bin/threads -> lib/
  File.expand_path('lib', __dir__),         # Flat: threads -> lib/
].each do |path|
  $LOAD_PATH.unshift(path) if File.directory?(path)
end

require 'optparse'
require 'fileutils'
require 'threads/workspace'
require 'threads/thread'
require 'threads/section'
require 'threads/git'
require 'threads/commands'

module Threads
  # CLI entry point
  class CLI
    EXIT_SUCCESS = 0
    EXIT_ERROR = 1
    EXIT_AMBIGUOUS = 2

    def initialize
      @ws = nil
    end

    def run(args)
      # Handle --help and -h at top level
      if args.empty? || args.include?('--help') || args.include?('-h')
        if args.length <= 1 || args[0] == '--help' || args[0] == '-h'
          print_help
          return EXIT_SUCCESS
        end
      end

      command = args.shift

      # Find workspace first
      begin
        @ws = Workspace.find
      rescue Threads::WorkspaceError => e
        $stderr.puts "Error: #{e.message}"
        return EXIT_ERROR
      end

      case command
      when 'list', 'ls'
        run_list(args)
      when 'new'
        run_new(args)
      when 'read'
        run_read(args)
      when 'path'
        run_path(args)
      when 'status'
        run_status(args)
      when 'update'
        run_update(args)
      when 'body'
        run_body(args)
      when 'note'
        run_note(args)
      when 'todo'
        run_todo(args)
      when 'log'
        run_log(args)
      when 'resolve'
        run_resolve(args)
      when 'reopen'
        run_reopen(args)
      when 'remove', 'rm'
        run_remove(args)
      when 'move'
        run_move(args)
      when 'git'
        run_git(args)
      when 'commit'
        run_commit(args)
      when 'validate'
        run_validate(args)
      when 'stats'
        run_stats(args)
      when '--help', '-h', 'help'
        print_help
        EXIT_SUCCESS
      else
        $stderr.puts "Unknown command: #{command}"
        $stderr.puts "Run 'threads --help' for usage."
        EXIT_ERROR
      end
    rescue Threads::AmbiguousReference => e
      $stderr.puts "Error: #{e.message}"
      EXIT_AMBIGUOUS
    rescue Threads::Error, ArgumentError, Errno::ENOENT, Errno::EACCES, IOError => e
      $stderr.puts "Error: #{e.message}"
      EXIT_ERROR
    end

    private

    def print_help
      puts <<~HELP
        threads - Persistent context management for LLM-assisted development

        Threads are markdown files in .threads/ directories at workspace, category,
        or project level. Each thread tracks a single topic: a feature, bug,
        exploration, or decision.

        USAGE:
          threads <command> [options] [arguments]

        WORKSPACE COMMANDS:
          list [path] [-r] [--search=X] [--status=X] [--include-closed] [--json]
                              List threads
          new [path] <title>  Create new thread
          move <id> <path>    Move thread to new location
          commit [--pending | <id>...] [-m msg]
                              Commit thread changes
          validate [path]     Validate thread files
          git                 Show pending thread changes
          stats [path] [-r]   Show thread count by status

        THREAD COMMANDS:
          read <id>           Read thread content
          path <id>           Print thread file path
          status <id> <status>  Change thread status
          update <id>         Update thread title/desc
          body <id> [--set|--append]
                              Edit Body section (stdin for content)
          note <id> <action>  Manage notes (add/edit/remove)
          todo <id> <action>  Manage todo items (add/check/uncheck/remove)
          log <id> [entry]    Add log entry
          resolve <id>        Mark thread resolved
          reopen <id>         Reopen resolved thread
          remove <id>         Remove thread entirely

        OPTIONS:
          -h, --help          Show this help message

        EXAMPLES:
          threads new . "Implement feature X"
          threads list -r
          threads read abc123
          threads status abc123 active
          echo "content" | threads body abc123 --set
          threads todo abc123 add "Task item"
          threads resolve abc123
      HELP
    end

    def run_list(args)
      opts = { recursive: false, include_closed: false, json: false }
      path = nil

      parser = OptionParser.new do |o|
        o.on('-r', '--recursive', 'Include nested categories/projects') { opts[:recursive] = true }
        o.on('--include-closed', 'Include resolved/terminal threads') { opts[:include_closed] = true }
        o.on('-s', '--search=TERM', 'Search name/title/desc') { |v| opts[:search] = v }
        o.on('--status=STATUS', 'Filter by status') { |v| opts[:status] = v }
        o.on('-c', '--category=CAT', 'Filter by category') { |v| opts[:category] = v }
        o.on('-p', '--project=PROJ', 'Filter by project') { |v| opts[:project] = v }
        o.on('--json', 'Output as JSON') { opts[:json] = true }
      end

      remaining = parser.parse(args)
      path = remaining[0] if remaining.length > 0
      opts[:path] = path

      Commands.list(@ws, opts)
      EXIT_SUCCESS
    end

    def run_new(args)
      opts = { status: 'idea' }
      path = nil
      title = nil

      parser = OptionParser.new do |o|
        o.on('--status=STATUS', 'Initial status') { |v| opts[:status] = v }
        o.on('--desc=DESC', 'One-line description') { |v| opts[:desc] = v }
        o.on('--body=BODY', 'Initial body content') { |v| opts[:body] = v }
      end

      remaining = parser.parse(args)

      if remaining.length == 2
        path = remaining[0]
        title = remaining[1]
      elsif remaining.length == 1
        title = remaining[0]
        path = Dir.pwd
      else
        raise ArgumentError, 'usage: threads new [path] <title>'
      end

      opts[:path] = path
      opts[:title] = title

      Commands.new_thread(@ws, opts)
      EXIT_SUCCESS
    end

    def run_read(args)
      raise ArgumentError, 'usage: threads read <id>' if args.empty?

      Commands.read(@ws, args[0])
      EXIT_SUCCESS
    end

    def run_path(args)
      raise ArgumentError, 'usage: threads path <id>' if args.empty?

      Commands.path(@ws, args[0])
      EXIT_SUCCESS
    end

    def run_status(args)
      raise ArgumentError, 'usage: threads status <id> <new-status>' if args.length < 2

      Commands.status(@ws, args[0], args[1])
      EXIT_SUCCESS
    end

    def run_update(args)
      opts = {}

      parser = OptionParser.new do |o|
        o.on('--title=TITLE', 'New title') { |v| opts[:title] = v }
        o.on('--desc=DESC', 'New description') { |v| opts[:desc] = v }
      end

      remaining = parser.parse(args)
      raise ArgumentError, 'usage: threads update <id> [--title=X] [--desc=X]' if remaining.empty?

      Commands.update(@ws, remaining[0], opts)
      EXIT_SUCCESS
    end

    def run_body(args)
      opts = {}

      parser = OptionParser.new do |o|
        o.on('--set', 'Replace body content') { opts[:set] = true }
        o.on('--append', 'Append to body content') { opts[:append] = true }
      end

      remaining = parser.parse(args)
      raise ArgumentError, 'usage: threads body <id> [--set|--append]' if remaining.empty?

      Commands.body(@ws, remaining[0], opts)
      EXIT_SUCCESS
    end

    def run_note(args)
      raise ArgumentError, 'usage: threads note <id> <action> [text|hash] [new-text]' if args.length < 2

      ref = args[0]
      action = args[1]
      rest = args[2..]

      Commands.note(@ws, ref, action, *rest)
      EXIT_SUCCESS
    end

    def run_todo(args)
      raise ArgumentError, 'usage: threads todo <id> <action> [item|hash]' if args.length < 2

      ref = args[0]
      action = args[1]
      rest = args[2..]

      Commands.todo(@ws, ref, action, *rest)
      EXIT_SUCCESS
    end

    def run_log(args)
      raise ArgumentError, 'usage: threads log <id> [entry]' if args.empty?

      ref = args[0]
      entry = args[1]

      Commands.log(@ws, ref, entry)
      EXIT_SUCCESS
    end

    def run_resolve(args)
      raise ArgumentError, 'usage: threads resolve <id>' if args.empty?

      Commands.resolve(@ws, args[0])
      EXIT_SUCCESS
    end

    def run_reopen(args)
      opts = {}

      parser = OptionParser.new do |o|
        o.on('--status=STATUS', 'Status to reopen to') { |v| opts[:status] = v }
      end

      remaining = parser.parse(args)
      raise ArgumentError, 'usage: threads reopen <id> [--status=X]' if remaining.empty?

      Commands.reopen(@ws, remaining[0], opts)
      EXIT_SUCCESS
    end

    def run_remove(args)
      raise ArgumentError, 'usage: threads remove <id>' if args.empty?

      Commands.remove(@ws, args[0])
      EXIT_SUCCESS
    end

    def run_move(args)
      raise ArgumentError, 'usage: threads move <id> <new-path>' if args.length < 2

      Commands.move(@ws, args[0], args[1])
      EXIT_SUCCESS
    end

    def run_git(_args)
      Commands.git(@ws)
      EXIT_SUCCESS
    end

    def run_commit(args)
      opts = { ids: [] }

      parser = OptionParser.new do |o|
        o.on('--pending', 'Commit all modified threads') { opts[:pending] = true }
        o.on('-m', '--message=MSG', 'Commit message') { |v| opts[:message] = v }
      end

      remaining = parser.parse(args)
      opts[:ids] = remaining unless remaining.empty?

      Commands.commit(@ws, opts)
      EXIT_SUCCESS
    end

    def run_validate(args)
      opts = {}

      parser = OptionParser.new do |o|
        o.on('-r', '--recursive', 'Validate recursively') { opts[:recursive] = true }
      end

      remaining = parser.parse(args)
      opts[:path] = remaining[0] if remaining.length > 0

      Commands.validate(@ws, opts)
      EXIT_SUCCESS
    end

    def run_stats(args)
      opts = {}

      parser = OptionParser.new do |o|
        o.on('-r', '--recursive', 'Include nested categories/projects') { opts[:recursive] = true }
      end

      remaining = parser.parse(args)
      opts[:path] = remaining[0] if remaining.length > 0

      Commands.stats(@ws, opts)
      EXIT_SUCCESS
    end
  end
end

exit Threads::CLI.new.run(ARGV)
